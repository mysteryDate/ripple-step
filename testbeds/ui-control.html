<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <style media="screen">
    body {
      margin: 0px;
      background-color: black;
      overflow: hidden;
    }
  </style>
  <!-- <script src="build/bundle.js"></script> -->
  <script src="../node_modules/three/build/three.js"></script>
  <script src="../build/testbed.bundle.js"></script>
</head>
<body>
  <div id="container"></div>
  <script>
    /* global THREE, RS */
    var container = document.getElementById("container");
    var renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    container.appendChild(renderer.domElement);
    var scene = new THREE.Scene();
    var camera = new THREE.OrthographicCamera(-window.innerWidth/2, window.innerWidth/2, window.innerHeight/2, -window.innerHeight/2, 0.1, 100);
    camera.position.set(0, 0, 50);

    function Knob(options) {
      THREE.Group.call(this);
      var SENSITIVITY = 0.5; // How many degrees the knob turns per pixel
      options = options || {};
      var minRotation = options.minRotation || 0;
      var maxRotation = options.maxRotation || -2 * Math.PI;
      var minValue = options.minValue || 0;
      var maxValue = options.maxValue || 100;
      var currentValue = options.currentValue || minValue;

      var isActive = false;
      var touchStartRotation = 0;
      var touchStartPos = new THREE.Vector2();

      RS.Textures.createTexture("sword_icon.png", "../textures/sword_icon.png");
      var tex = RS.Textures.get("sword_icon.png");
      var bodyGeom = new THREE.CircleBufferGeometry(150, 100);
      var bodyMat = new THREE.MeshBasicMaterial({color: "pink", map: tex});
      var body = new THREE.Mesh(bodyGeom, bodyMat);
      this.add(body);

      function getRotationFromValue(value) {
        return THREE.Math.mapLinear(value, minValue, maxValue, minRotation, maxRotation);
      }
      function getValueFromRotation(rotation) {
        return THREE.Math.mapLinear(rotation, minRotation, maxRotation, minValue, maxValue);
      }

      body.rotation.z = getRotationFromValue(currentValue);

      this.getValue = function() {
        return currentValue;
      };

      this.touchStart = function(raycaster, mouse) {
        var touch = raycaster.intersectObjects(this.children)[0];
        if (touch) {
          isActive = true;
          touchStartPos = mouse;
          touchStartRotation = body.rotation.z;
        }
      };

      this.touchEnd = function() {
        isActive = false;
      };

      this.touch = function(mouse) {
        if (isActive) {
          var touchDiff = touchStartPos.y - mouse.y;
          var newRotation = touchStartRotation + THREE.Math.degToRad(SENSITIVITY * touchDiff);
          newRotation = THREE.Math.clamp(newRotation, maxRotation, minRotation); // Because rotations are counter-clockwise
          body.rotation.z = newRotation;
          currentValue = getValueFromRotation(newRotation);
          console.log(currentValue);
        }
      };
    }
    Knob.prototype = Object.create(THREE.Object3D.prototype);

    var knob = new Knob({
      minRotation: -Math.PI,
      maxRotation: Math.PI - 2 * Math.PI / 3,
      minValue: 0.005,
      maxValue: 1,
    });
    scene.add(knob);

    function update() {
      renderer.render(scene, camera);
      requestAnimationFrame(update);
    }

    var raycaster = new THREE.Raycaster();
    function onDocumentMouseDown(event) {
      var mouse = new THREE.Vector2();
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);
      knob.touchStart(raycaster, new THREE.Vector2(event.clientX, -event.clientY));
    }
    function onDocumentMouseMove(event) {
      var mouse = new THREE.Vector2();
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      knob.touch(new THREE.Vector2(event.clientX, -event.clientY));
    }
    function onDocumentMouseUp(event) {
      knob.touchEnd();
    }

    document.addEventListener("mousemove", onDocumentMouseMove, false);
    document.addEventListener("mousedown", onDocumentMouseDown, false);
    document.addEventListener("mouseup", onDocumentMouseUp, false);

    renderer.render(scene, camera);
    window.setTimeout(function() {
      update();
    }, 100);
  </script>
</body>
</html>
